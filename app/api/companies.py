from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt
from marshmallow import Schema, fields, validates, ValidationError
from app.extensions import db
from app.models.company import Company


bp = Blueprint('companies', __name__)


class CreateCompanySchema(Schema):
    name = fields.Str(required=True, error_messages={
        "required": "Company name is required"
    })
    linkedin_url = fields.Str(required=True, error_messages={
        "required": "LinkedIn URL is required"
    })

    @validates('name')
    def validate_name(self, value):
        if len(value.strip()) < 2:
            raise ValidationError("Company name must be at least 2 characters")
        if len(value) > 255:
            raise ValidationError("Company name must be less than 255 characters")

    @validates('linkedin_url')
    def validate_linkedin_url(self, value):
        # Basic LinkedIn company URL validation
        # Accepts forms like: https://www.linkedin.com/company/<slug>/ ... or linkedin.com/company/<slug>
        import re
        pattern = r"^(https?:\/\/)?(www\.)?linkedin\.com\/company\/[A-Za-z0-9-_.%]+\/?(.*)?$"
        if not re.match(pattern, value.strip()):
            raise ValidationError("Invalid LinkedIn company URL")


create_company_schema = CreateCompanySchema()


@bp.route('', methods=['POST'])
@jwt_required()
def create_company():
    """Create a LinkedIn company to track for the current tenant.

    Flow:
    1. Receive: name, linkedin_url
    2. Validate: LinkedIn URL format
    3. Check: company not already added by this tenant (by linkedin_url)
    4. Create: company record with tenant_id from JWT
    5. Return: 201 with company object
    """

    data = request.get_json() or {}

    try:
        validated = create_company_schema.load(data)
    except ValidationError as err:
        return jsonify({"error": "Validation failed", "details": err.messages}), 400

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        # Should not happen if tokens are generated by our backend, but guard anyway
        return jsonify({"error": "Unauthorized"}), 401

    name = validated['name'].strip()
    linkedin_url = validated['linkedin_url'].strip()

    # Duplicate check per tenant (by linkedin_url)
    existing = Company.query.filter_by(tenant_id=tenant_id, linkedin_url=linkedin_url).first()
    if existing:
        return jsonify({"error": "Company already added for this tenant"}), 400

    company = Company(
        tenant_id=tenant_id,
        name=name,
        linkedin_url=linkedin_url,
        is_active=True,
    )

    db.session.add(company)
    db.session.commit()

    company_obj = {
        "company_id": company.company_id,
        "tenant_id": company.tenant_id,
        "name": company.name,
        "linkedin_url": company.linkedin_url,
        "is_active": company.is_active,
        "created_at": company.created_at.isoformat() if company.created_at else None,
    }

    return jsonify({"company": company_obj}), 201


@bp.route('', methods=['GET'])
@jwt_required()
def list_companies():
    """List companies for the current tenant with pagination and filtering.

    Query Params:
      - page: int (default 1)
      - limit: int (default 20, max 100)
      - is_active: bool (optional) -> true/false
    """

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        return jsonify({"error": "Unauthorized"}), 401

    # Pagination params
    try:
        page = int((request.args.get('page') or '1').strip())
    except Exception:
        page = 1
    if page < 1:
        page = 1

    try:
        limit = int((request.args.get('limit') or '20').strip())
    except Exception:
        limit = 20
    if limit < 1:
        limit = 20
    if limit > 100:
        limit = 100

    # Optional is_active filter
    is_active_param = request.args.get('is_active')
    query = Company.query.filter_by(tenant_id=tenant_id)
    if is_active_param is not None:
        val = is_active_param.strip().lower()
        if val in ('true', '1', 'yes'):
            query = query.filter(Company.is_active.is_(True))
        elif val in ('false', '0', 'no'):
            query = query.filter(Company.is_active.is_(False))
        # else: ignore invalid values and return unfiltered

    total = query.count()

    items = (
        query
        .order_by(Company.created_at.desc())
        .offset((page - 1) * limit)
        .limit(limit)
        .all()
    )

    companies = []
    for c in items:
        companies.append({
            "company_id": c.company_id,
            "name": c.name,
            "linkedin_url": c.linkedin_url,
            "is_active": c.is_active,
            "created_at": c.created_at.isoformat() if c.created_at else None,
        })

    # Return array and minimal pagination metadata
    return jsonify({
        "companies": companies,
        "page": page,
        "limit": limit,
        "total": total
    }), 200


