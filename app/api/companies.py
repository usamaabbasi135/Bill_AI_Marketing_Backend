from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt
from marshmallow import Schema, fields, validates, ValidationError
from app.extensions import db
from app.models.company import Company


bp = Blueprint('companies', __name__)


class CreateCompanySchema(Schema):
    name = fields.Str(required=True, error_messages={
        "required": "Company name is required"
    })
    linkedin_url = fields.Str(required=True, error_messages={
        "required": "LinkedIn URL is required"
    })

    @validates('name')
    def validate_name(self, value):
        if len(value.strip()) < 2:
            raise ValidationError("Company name must be at least 2 characters")
        if len(value) > 255:
            raise ValidationError("Company name must be less than 255 characters")

    @validates('linkedin_url')
    def validate_linkedin_url(self, value):
        # Basic LinkedIn company URL validation
        # Accepts forms like: https://www.linkedin.com/company/<slug>/ ... or linkedin.com/company/<slug>
        import re
        pattern = r"^(https?:\/\/)?(www\.)?linkedin\.com\/company\/[A-Za-z0-9-_.%]+\/?(.*)?$"
        if not re.match(pattern, value.strip()):
            raise ValidationError("Invalid LinkedIn company URL")


create_company_schema = CreateCompanySchema()


class UpdateCompanySchema(Schema):
    name = fields.Str(required=False)
    linkedin_url = fields.Str(required=False)
    is_active = fields.Boolean(required=False)

    @validates('name')
    def validate_name(self, value):
        if value is None:
            return
        if len(value.strip()) < 2:
            raise ValidationError("Company name must be at least 2 characters")
        if len(value) > 255:
            raise ValidationError("Company name must be less than 255 characters")

    @validates('linkedin_url')
    def validate_linkedin_url(self, value):
        if value is None:
            return
        import re
        pattern = r"^(https?:\/\/)?(www\.)?linkedin\.com\/company\/[A-Za-z0-9-_.%]+\/?(.*)?$"
        if not re.match(pattern, value.strip()):
            raise ValidationError("Invalid LinkedIn company URL")


@bp.route('', methods=['POST'])
@jwt_required()
def create_company():
    """Create a LinkedIn company to track for the current tenant.

    Flow:
    1. Receive: name, linkedin_url
    2. Validate: LinkedIn URL format
    3. Check: company not already added by this tenant (by linkedin_url)
    4. Create: company record with tenant_id from JWT
    5. Return: 201 with company object
    """

    data = request.get_json() or {}

    try:
        validated = create_company_schema.load(data)
    except ValidationError as err:
        return jsonify({"error": "Validation failed", "details": err.messages}), 400

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        # Should not happen if tokens are generated by our backend, but guard anyway
        return jsonify({"error": "Unauthorized"}), 401

    name = validated['name'].strip()
    linkedin_url = validated['linkedin_url'].strip()

    # Duplicate check per tenant (by linkedin_url)
    existing = Company.query.filter_by(tenant_id=tenant_id, linkedin_url=linkedin_url).first()
    if existing:
        return jsonify({"error": "Company already added for this tenant"}), 400

    company = Company(
        tenant_id=tenant_id,
        name=name,
        linkedin_url=linkedin_url,
        is_active=True,
    )

    db.session.add(company)
    db.session.commit()

    company_obj = {
        "company_id": company.company_id,
        "name": company.name,
        "linkedin_url": company.linkedin_url,
        "is_active": company.is_active,
        "created_at": company.created_at.isoformat() if company.created_at else None,
    }

    return jsonify({"company": company_obj}), 201


@bp.route('', methods=['GET'])
@jwt_required()
def list_companies():
    """List companies for the current tenant with pagination and filtering.

    Query Params:
      - page: int (default 1)
      - limit: int (default 20, max 100)
      - is_active: bool (optional) -> true/false
    """

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        return jsonify({"error": "Unauthorized"}), 401

    # Pagination params
    try:
        page = int((request.args.get('page') or '1').strip())
    except Exception:
        page = 1
    if page < 1:
        page = 1

    try:
        limit = int((request.args.get('limit') or '20').strip())
    except Exception:
        limit = 20
    if limit < 1:
        limit = 20
    if limit > 100:
        limit = 100

    # Optional is_active filter
    is_active_param = request.args.get('is_active')
    query = Company.query.filter_by(tenant_id=tenant_id)
    if is_active_param is not None:
        val = is_active_param.strip().lower()
        if val in ('true', '1', 'yes'):
            query = query.filter(Company.is_active.is_(True))
        elif val in ('false', '0', 'no'):
            query = query.filter(Company.is_active.is_(False))
        # else: ignore invalid values and return unfiltered

    total = query.count()

    items = (
        query
        .order_by(Company.created_at.desc())
        .offset((page - 1) * limit)
        .limit(limit)
        .all()
    )

    companies = []
    for c in items:
        companies.append({
            "company_id": c.company_id,
            "name": c.name,
            "linkedin_url": c.linkedin_url,
            "is_active": c.is_active,
            "created_at": c.created_at.isoformat() if c.created_at else None,
        })

    # Return array and minimal pagination metadata
    return jsonify({
        "companies": companies,
        "page": page,
        "limit": limit,
        "total": total
    }), 200


@bp.route('/<company_id>', methods=['PATCH'])
@jwt_required()
def update_company(company_id):
    """Update a company's fields for the current tenant.

    Allowed fields: name, linkedin_url, is_active
    Validates tenant ownership and prevents duplicate linkedin_url per tenant.
    """

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        return jsonify({"error": "Unauthorized"}), 401

    company = Company.query.filter_by(company_id=company_id).first()
    if not company:
        return jsonify({"error": "Company not found"}), 404

    if company.tenant_id != tenant_id:
        return jsonify({"error": "Forbidden"}), 403

    data = request.get_json() or {}
    try:
        validated = UpdateCompanySchema().load(data)
    except ValidationError as err:
        return jsonify({"error": "Validation failed", "details": err.messages}), 400

    # If linkedin_url provided, ensure not duplicate for this tenant (excluding current)
    new_linkedin = validated.get('linkedin_url')
    if new_linkedin:
        existing = Company.query.filter(
            Company.tenant_id == tenant_id,
            Company.linkedin_url == new_linkedin,
            Company.company_id != company.company_id
        ).first()
        if existing:
            return jsonify({"error": "Company already added for this tenant"}), 400

    if 'name' in validated:
        company.name = validated['name'].strip()
    if 'linkedin_url' in validated:
        company.linkedin_url = validated['linkedin_url'].strip()
    if 'is_active' in validated:
        company.is_active = bool(validated['is_active'])

    db.session.commit()

    company_obj = {
        "company_id": company.company_id,
        "name": company.name,
        "linkedin_url": company.linkedin_url,
        "is_active": company.is_active,
        "created_at": company.created_at.isoformat() if company.created_at else None,
    }

    return jsonify({"company": company_obj}), 200


@bp.route('/<company_id>', methods=['DELETE'])
@jwt_required()
def delete_company(company_id):
    """Soft delete a company (set is_active=false) for the current tenant."""

    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        return jsonify({"error": "Unauthorized"}), 401

    company = Company.query.filter_by(company_id=company_id).first()
    if not company:
        return jsonify({"error": "Company not found"}), 404

    if company.tenant_id != tenant_id:
        return jsonify({"error": "Forbidden"}), 403

    company.is_active = False
    db.session.commit()

    company_obj = {
        "company_id": company.company_id,
        "name": company.name,
        "linkedin_url": company.linkedin_url,
        "is_active": company.is_active,
        "created_at": company.created_at.isoformat() if company.created_at else None,
    }

    return jsonify({"company": company_obj}), 200


@bp.route('/<company_id>/scrape', methods=['POST'])
@jwt_required()
def scrape_company(company_id):
    """Trigger LinkedIn post scraping for a company using Apify.
    
    Query Params or Body:
      - max_posts (int, optional, default: 100): Maximum number of posts to scrape (1-1000)
    
    Returns job_id immediately (async task).
    """
    claims = get_jwt()
    tenant_id = claims.get('tenant_id')
    if not tenant_id:
        return jsonify({"error": "Unauthorized"}), 401
    
    # Verify company exists and belongs to tenant
    company = Company.query.filter_by(company_id=company_id).first()
    if not company:
        return jsonify({"error": "Company not found"}), 404
    
    if company.tenant_id != tenant_id:
        return jsonify({"error": "Forbidden"}), 403
    
    if not company.is_active:
        return jsonify({"error": "Company is inactive"}), 400
    
    # Get max_posts from query params or request body
    max_posts = 100  # default
    if request.args.get('max_posts'):
        try:
            max_posts = int(request.args.get('max_posts'))
            if max_posts < 1:
                max_posts = 1
            if max_posts > 1000:  # Reasonable limit
                max_posts = 1000
        except ValueError:
            return jsonify({"error": "max_posts must be a valid integer"}), 400
    
    # Also check request body (if Content-Type is application/json)
    data = {}
    if request.is_json:
        try:
            data = request.get_json() or {}
        except Exception:
            # If JSON parsing fails, just use empty dict
            data = {}
    
    if data.get('max_posts'):
        try:
            max_posts = int(data.get('max_posts'))
            if max_posts < 1:
                max_posts = 1
            if max_posts > 1000:
                max_posts = 1000
        except ValueError:
            return jsonify({"error": "max_posts must be a valid integer"}), 400
    
    # Import task here to avoid circular imports
    from app.tasks.scraper import scrape_company_posts
    
    # Start async Celery task
    try:
        task = scrape_company_posts.delay(company_id, max_posts)
        return jsonify({
            "message": "Scraping job started",
            "job_id": task.id,
            "company_id": company_id,
            "max_posts": max_posts,
            "status_url": f"/api/jobs/{task.id}"  # Future endpoint for job status
        }), 202
    except Exception as e:
        return jsonify({
            "error": "Failed to start scraping job",
            "details": str(e)
        }), 500

